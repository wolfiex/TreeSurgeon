<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node circle {
  fill: #999;
}

.node text {
  font: 10px sans-serif;
}

.node--internal circle {
  fill: #555;
}

.node--internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

</style>
<svg></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

Object.prototype.getKeyByValue = function( value ) {
    for( var prop in this ) {
        if( this.hasOwnProperty( prop ) ) {
             if( this[ prop ] === value )
                 return prop;
        }
    }
}

nodes =[]
links =[]
lnk={}
lnkparent={}
treeData=[]



start(require('electron').remote.dialog.showOpenDialog())



function start(file){
d3.text(file, function(data) { window.data=data.split(';');
window.data.map(d=> {
 if (d.match(/.*->.*/)) {links.push(d)}else if (d.match(/.*label.*/)){nodes.push(d)}
})
links = links.map(d=>[d.match(/(\d+)\s*->/)[1],d.match(/->\s+(\d+)/)[1]])
nodes = nodes.map(d=>[d.match(/(\d+)\s*\[label/)[1],d.match(/\d+\s*\[label="(.*)"/)[1]])
nodes.forEach(d=>{lnk[d[0]]=[];lnkparent[d[0]]=[]})

window.nds = new Map(nodes)
links.forEach(d=>{lnk[d[0]].push(d[1]);lnkparent[d[1]].push(d[0])}) //parents

start = Object.keys(lnk)[d3.max(Object.values(lnk).map((d,i)=>d.length===0?i:-1))]

var flatData = Object.keys(lnkparent).map(d=>{return{'name':d,'parent':lnkparent[d][0]?lnkparent[d][0]:null}})


// convert the flat data into a hierarchy
window.treeData = d3.stratify()
  .id(function(d) { return d.name; })
  .parentId(function(d) { return d.parent; })
  (flatData);

// assign the name to each node
treeData.each(function(d) {
    d.name = d.id;
  });

  window.col = d3.scaleSequential(d3["interpolate" + 'Viridis'])
            .domain([0, treeData.height]);
run(treeData)
})

}


var svg = d3.select("svg"),
    width = window.innerWidth,
    height = window.innerHeight,
    g = svg.attr('width',width).attr('height',height).append("g").attr("transform", "translate(" + (width / 2 ) + "," + (height / 2 ) + ")");

var stratify = d3.stratify()
    .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });

var tree = d3.tree()
    .size([2 * Math.PI, 00])
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });

function run(treedata){


  // declares a tree layout and assigns the size
  var treemap = d3.tree()
      .size([height, width]);


var treemap = d3.tree()
    .size([2 * Math.PI, height/3])
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });

  //  assigns the data to a hierarchy using parent-child relationships
  var nodes = d3.hierarchy(treedata, function(d) {
      return d.children;
    });

  // maps the node data to the tree layout
  global = treemap(nodes);
  //var root = tree(stratify(data));

  var link = g.selectAll(".link")
    .data(global.links())
    .enter().append("path")
      .attr("class", "link")
      .attr("d", d3.linkRadial()
          .angle(function(d) { return d.x; })
          .radius(function(d) { return d.y; }));

  var node = g.selectAll(".node")
    .data(global.descendants())
    .enter().append("g")
      .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
      .attr("transform", function(d) { return "translate(" + radialPoint(d.x, d.y) + ")"; });


  node.append("circle")
      .attr("r", 4)
      .on('click',function(d) { alert( window.nds.get(d.data.id).split('\\n') )})
      .on('mouseover',function(d) { console.log(d)})
      .style('fill',d=>window.col(d.height))

  node.append("text")
      .attr("dy", "0.31em")
      .attr("x", function(d) { return d.x < Math.PI === !d.children ? 6 : -6; })
      .attr("text-anchor", function(d) { return d.x < Math.PI === !d.children ? "start" : "end"; })
      .attr("transform", function(d) { return "rotate(" + (d.x < Math.PI ? d.x - Math.PI / 2 : d.x + Math.PI / 2) * 180 / Math.PI + ")"; })
      .text(function(d) { return window.nds.get(d.data.id).split('\\n')[0] });
};

function radialPoint(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

</script>
<button type="button" onclick='d3.select("svg").selectAll("text").remove()'>Remove Labels</button>
