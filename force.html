<!DOCTYPE html>
<meta charset="utf-8">

<svg id = 'svg' width="1200" height="800"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="annotate.js"></script>
    <script src="d3-legend.js"></script>
    <script src ="d3-ForceEdgeBundling.js"></script>

        <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>

<script>

window.sidetree = false;
window.iterate =  2
window.charge= 20890
window.forcex=.02
window.divisor =35


Object.prototype.getKeyByValue = function(value) {
  for (var prop in this) {
    if (this.hasOwnProperty(prop)) {
      if (this[prop] === value) return prop;
    }
  }
};

nodes = [];links = [];lnk = {};lnkparent = {};treeData = [];
const dict = arr => Object.assign(...arr.map(([k, v]) => ({ [k]: v })));


start(require('electron').remote.dialog.showOpenDialog())
//start("tree.dot");


nodes = [];links = [];lnk = {};lnkparent = {};treeData = [];

function start(file) {
  d3.text(file, function(data) {
    window.data = data.split(";");
    window.data.map(d => {
      if (d.match(/.*->.*/)) {
        links.push(d);
      } else if (d.match(/.*label.*/)) {
        nodes.push(d);
      }
    });
    links = links.map(d => [
      d.match(/(\d+)\s*->/)[1],
      d.match(/->\s+(\d+)/)[1]
    ]);
    nodes = nodes.map(d => [
      d.match(/(\d+)\s*\[label/)[1],

      dict(
        ("label = " + d.match(/\d+\s*\[label="(.*)"/)[1])
          .split("\\n")
          .map(e => e.split(" = "))
      )
    ]);
    nodes = nodes.map(d => {
      d[1].type = d[1].label.split(" <=")[0];
      return d;
    });
    nodes.forEach(d => {
      lnk[d[0]] = [];
      lnkparent[d[0]] = [];
    });

    window.nds = new Map(nodes);
    links.forEach(d => {
      lnk[d[0]].push(d[1]);
      lnkparent[d[1]].push(d[0]);
    }); //parents

    start = Object.keys(lnk)[
      d3.max(Object.values(lnk).map((d, i) => (d.length === 0 ? i : -1)))
    ];

    var flatData = Object.keys(lnkparent).map(d => {
      return { name: d, parent: lnkparent[d][0] ? lnkparent[d][0] : null };
    });

    // convert the flat data into a hierarchy
    window.treeData = d3
      .stratify()
      .id(function(d) {
        return d.name;
      })
      .parentId(function(d) {
        return d.parent;
      })(flatData);

    // assign the name to each node
    treeData.each(function(d) {
      d.name = d.id;
    });

    window.col = d3
      .scaleSequential(d3["interpolate" + "Viridis"])
      .domain([0, 1]); //treeData.height]);

    var treemap = d3.tree();

    //  assigns the data to a hierarchy using parent-child relationships
    var nn = d3.hierarchy(treeData, function(d) {
      return d.children;
    });

    // maps the node data to the tree layout
    window.g = d3.tree()(nn); //.decendants());

    window.treedepth = new Map(
      g.descendants().map(d => {
        return [d.data.id, d.depth];
      })
    );

    window.scaledepth = function(x) {
      return  -2.5*(nodes[0].samples / 40) + (
        (1 -
          0.85 *
            (Math.log(parseFloat(1 + x)) /
              Math.log(parseFloat(treeData.height)))) *
        d3.select("svg").attr("height")
      );
    };

    window.scalewidth = function(x) {
      return Math.pow(
        1 -
          0.9 *
            (Math.log(parseFloat(1 + window.treedepth.get(x))) /
              Math.log(parseFloat(treeData.height))),
        8
      );
    };


    window.groups = new Set(nodes.map(d => d[1].type));
    groups = dict([...groups].map((d, i) => [d, i / [...groups].length]));

    nodes = nodes.map(d => {
      var e = d[1];
      e.id = d[0];
      e.group = 0;

      if (window.sidetree) {e.fx=e.id};


      return e;
    });
    links = links.map(d => {
      return {
        source: d[0],
        target: d[1],
        value: parseFloat(nds.get(d[0]).samples)
      };
    });

    run({ nodes, links });
  });
}

var svg = d3.select("svg").attr('width',innerWidth).attr('height',innerHeight),
  width = +svg.attr("width"),
  height = +svg.attr("height");


  svg.style('background-color','#222')


var color = d3.scaleOrdinal(d3.schemeCategory20);

var simulation = d3
  .forceSimulation()
  .force(
    "link",
    d3
      .forceLink()
      .id(function(d) {
        return d.id;
      })
      .strength(1)
      .distance(d => 0.1 + 0 * Math.sqrt(d.value / 100))
  )
  .force(
    "charge",
    d3.forceManyBody().strength(d =>
      {return -window.charge *  d.value * d.samples *window.scalewidth(d.id)})
  )

  //.force("center", d3.forceCenter(width / 2, height / 2))

  .force(
    "forceX",
    d3
      .forceX()
      .strength(window.forcex)
      .x(width * 0.5)
  );
//.force("forceY", d3.forceY().strength(d=>(d.id==='0')?3:-0.0001).y(height * .95))

//.force("grow", d3.forceY().strength(d=>.1).y(0.1*height))
//.force('sunlight',d3.forceRadial().radius(height*.38).x(width/2).y(height).strength(.1))

var graph;
function run(graph) {
  var link = svg
    .append("g")
    .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter()
    .append("line")
    .attr("stroke-width", function(d) {
      return Math.sqrt(
        parseFloat(nds.get(d.source).samples) -
          parseFloat(nds.get(d.target).samples)
      );
    });

  var node = svg
    .append("g")
    .attr("class", "nodes")
    .selectAll("circle")
    .data(graph.nodes)
    .enter()
    .append("circle")
    .attr("r", d => 1 + d.samples / 40)
    .attr("id", d => "n" + d.id)

    //.attr("cy", d => window.scaledepth(window.treedepth.get(d.id)))
    //.attr("fy", d => window.scaledepth(window.treedepth.get(d.id)))
    .attr("fill", function(d) {
      return color(d.type);
    })
    .attr("opacity", 0.2)
    .call(
      d3
        .drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended)
    )
    .on("mouseover", d => console.log(d));

  node.append("title").text(function(d) {
    return d.id;
  });

  simulation.nodes(graph.nodes).on("tick", ticked);

  simulation.force("link").links(graph.links);

  function ticked() {
    if (simulation.alpha() < 0.1) {

      if (window.iterate <1){
      simulation.stop();


      var extent = d3.extent(nodes.map(d=>d.x))
      var myscale = d3.scaleLinear().range([0.025*width,0.9*width]).domain(extent)

      nodes.map(d=>{d.x=myscale(d.x);d.y-= 1 + nodes[0].samples / 40 ;return d})

      link
        .attr("x1", function(d) {
          return d.source.x;
        })
        .attr("x2", function(d) {
          return d.target.x;
        })
        .attr("y1", d => window.scaledepth(window.treedepth.get(d.source.id)))
        .attr("y2", d => window.scaledepth(window.treedepth.get(d.target.id)));
      node
          .attr("cx", d=> d.x)
          .attr("cy", d => window.scaledepth(window.treedepth.get(d.id)));

      annotate();
    } else {
      window.iterate -=1;
      simulation.alpha(1)
      console.log(iterate)

    }

    }

    link
      .attr("x1", function(d) {
        return d.source.x;
      })
      //.attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) {
        return d.target.x;
      })
      //.attr("y2", function(d) { return d.target.y; });

      .attr("y1", d => window.scaledepth(window.treedepth.get(d.source.id)))

      .attr("y2", d => window.scaledepth(window.treedepth.get(d.target.id)));

    node
      .attr("cx", function(d) {
        return d.x;
      })
      //  .attr("cy", function(d) { return d.y; });
      .attr("cy", d => window.scaledepth(window.treedepth.get(d.id)));
  }
}

function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

annotations = links.map(d => {
  n1 = d.source;
  n2 = d.target;

  return {
    note: {
      label: "",
      title: ""
    },
    dy: n2.x - n1.x,
    dx: n2.y - n1.y,
    x: n1.x,
    y: n1.y,
    type: d3.annotationCalloutCircle,
    subject: {
      radius: 10,
      radiusPadding: 10
    }
  };
});

window.makeAnnotations = d3
  .annotation()
  .annotations(annotations)
  .accessors({ x: d => d.x, y: d => d.y });

svg.attr("class", "annotation-encircle").call(makeAnnotations);
</script>
